\subsection{Principles}
\begin{defnbox}\nospacing
  \begin{defn}[Encapsulation]\label{defn:encapsulation}\leavevmode
    \begin{itemizenosep}
      \item Methods and data are combined in classes
      \item Not unique to OOP
    \end{itemizenosep}
  \end{defn}
\end{defnbox}
\subsection{Class Basics}
\subsubsection{Static}
\label{subsubsec:Static}
\begin{defnbox}\nospacing
  \begin{defn}[Static Fields]\label{defn:staticFields}
    Per class fields that exist only per class ($\neq$ per object), accessible via class (or instance)
    \begin{itemizenosep}
        \item Bound to class (available even if no instance has been created)
        \item Only one copy of the attribute (identical for all instances)
        \item Initialization per default with zero (0 / 0.0 / false / null) 
    \end{itemizenosep}
    \begin{mintlinebox}{java}
      static Type ref;
    \end{mintlinebox}
  \end{defn}
\end{defnbox}
\begin{stylebox}[Constants]\nospacing
  Declare constants as \javainline{static final} fields.
\end{stylebox}
\begin{defnbox}\nospacing
  \begin{defn}[Static Methods]\label{defn:staticFields}
    Per Class methods, accessible via class (or instance):
    \begin{mintlinebox}{java}
      static ResultType Name(args){ Body }
    \end{mintlinebox}
    \begin{itemizenosep}
        \item No \javainline{this}
        \item No access to instance attributes \& methods
    \end{itemizenosep}
  \end{defn}
\end{defnbox}
\begin{stylebox}\nospacing
  Do not use instances to access static fields or methods.
\end{stylebox}
\subsubsection{Class Initialization}
\begin{sectionbox}[Upon loading o the class]\nospacing
  
\end{sectionbox}
\subsection{Inheritance}
\begin{defnbox}\nospacing
  \begin{defn}[\tc{black}{\normalfont{(Implementation Aspect)}}
    \\Code Inheritance\bslash Extension\bslash Subclassing]\leavevmode
    \begin{itemizenosep}
        \item Subclasses add new fields \& methods
        \item Subclasses have more (specialized) attributes \& operations
        \item Implementation aspect
    \end{itemizenosep}
    \imp{Class}: defines a type \imp{and} implementation
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[\tc{black}{\normalfont{(Design Aspect)}}
    \\Interface Inheritance\bslash Specialization\bslash Subtyping]\leavevmode
    \begin{itemizenosep}
        \item Types define a set of objects
        \item Subtypes are specializations of this Type
        \item Inheritance of behavioral aspects
    \end{itemizenosep}
    \imp{Interface}: defines type
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[\javainline{extends}]\label{defn:extends}\leavevmode\\
    Define new class by extending existing classes.\\
    In Java only one base class can be specified to inherit from.
    Extension inherits all fields and methods from the base class.
  \end{defn}
\end{defnbox}
\subsubsection{Polymorphism}
\begin{defnbox}\nospacing
  \begin{defn}[Type Checking]
    The process of verifying and enforcing the constraints of types
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Statically Typed Languages]
    Is a language where the type of a variable is known at compile time.\\
    For some languages this means that we as programmer must specify of what type each variable is.\\
    \Advantage\ can do type-checking during compile time by the compiler, and therefore a lot of trivial bugs are caught at a very early stage.\\
    \imp{Examples}: C, C++, Java
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Dynamically Typed Languages]
     If the type is associated with/depends on run-time \imp{values}, and not named variables/fields/etc\\
     \Advantage\ we do not have to specify types every time.\\
     \Drawback\ need to do type checking at run-time
  \end{defn}
\end{defnbox}
\label{subsubsec:Polymorphism}
\begin{defnbox}\nospacing
  \begin{defn}[Polymorphism]\label{defn:polymorphism}
    Polymorphism allows operations to be performed on objects without needing to know which class the object belongs to,
    provided that we can guarantee that the class implements the specified type.
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Polymorphic Assignment]
    Instances of an extended class can be assigned to references of type base
    class:
    \begin{mintlinebox}{java}
      BaseClass ref = new extendedClass();
    \end{mintlinebox}
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Dynamic Type]\label{defn:dynamicType}
    Is the type of the object assigned to a reference variable.\\
    Dynamic types of reference variables may change with every assignment.\\
    $\text{Dynamic Type}\subseteq\text{Static Type}$ as the dynamic type must
    full fill at least the guarantees of the static type.
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Static Binding]
    Is type resolution based on the static type of a variable reference.
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Static Binding and Overloading]
    If we overload a method in Java, the compiler will produce a version for
    each overloaded function \rd{signature}.\\
    The resolution of the method signature (not to the actual implementation) of the
    method is done during compile time and does hence depend on the \rd{static type}
    passed to the method $\Rightarrow$ static binding
    \begin{mintlinebox}{java}
      StaticTypeOfa a = new DynamicTypeOfa();
      a.methodToResolveTo(StaticTypeOfb b);
    \end{mintlinebox}
    \javainline{staticTypeOfb} decides which overloaded method to call.
    \todo[inline]{Check if thats correct}
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[\\Dynamic Type Binding and Overloading]
    The runtime chooses a function implementation
    \begin{numberlistnosep}
        \item Based on the function \rd{signature} chosen at compile time
      (static binding)
        \item Depending on the dynamic type of the object referenced by
      \javainline{a} in order to chose an actual implementation of
      \begin{mintlinebox}{java}
          DynamicTypeOfa.methodToResolveTo(StaticTypeOfb b)
      \end{mintlinebox}
    \end{numberlistnosep}
    \todo[inline]{Check if thats correct}
  \end{defn}
\end{defnbox}
\begin{notebox}[Note]\nospacing
  For non-overloaded methods only the dynamic type of the reference variable
  decides which method to call.
    \todo[inline]{Check if thats correct}
\end{notebox}
\begin{notebox}[Static Class methods]\nospacing
  Cannot be overriden because they are not dispatched on the object instance at
  runtime. The compiler decides which method gets called.\\
  \imp{Thus} even if we overwrite them (and the compiler does not complain),
  it will always be called the method of the static type and not the dynamic.
\end{notebox}
\begin{codeboxNl}[Dynamic Type Inference]{java}
  if( ref instanceof Type)
\end{codeboxNl}
\todo[inline]{check if this is only for conceret or also base type}
\begin{notebox}[Note]\nospacing
    A runtime error is thrown if the dynamic type of \javainline{ref} is not a Type or extension thereof. (Type) ref;
\end{notebox}
\begin{defnbox}\nospacing
  \begin{defn}[Covariant Typing]\label{defn:covariantTying}
    Covariant return, means that when one overrides a method, the return type
    of the overriding method is allowed to be a subtype of the overridden
    method's return type.\\
    This allows to narrow down return type of an overridden method
    without any need to cast the type or check the return type.\\
    \imp{Thus}: Co-variant return types follow the \rd{Liskov substitution principle}.
  \end{defn}
\end{defnbox}
\begin{notebox}[Note: Invariant Types]\nospacing
    Before Java 5.0 it was not possible change the return type of an overriden
    method, the return type was said to be \rd{invariant}.
\end{notebox}
\begin{codeboxNl}[Covariant Example]{java}
  public class Animal {
      protected Food seekFood() {
          return new Food();
      }
  }

  public class Dog extends Animal {
    @Override
    protected Food seekFood() {
        // covariant return type
        return new DogFood();
    }
}
\end{codeboxNl}
\subsection{Abstract Classes}
\begin{defnbox}\nospacing
  \begin{defn}[Abstract Methods]
    Are methods that only define a signature/are only a declaration:
    \begin{mintlinebox}{java}
      visibility abstract retrunType methodName();
    \end{mintlinebox}
    \begin{itemizenosep}
        \item Define methods to be implemented in subclasses
        \item Can only be declared in \javainline{abstract} classes
        \item Cannot be \javainline{private} as private methods cannot be overridden
        \item Cannot be \javainline{static} as static methods cannot be overridden
    \end{itemizenosep}
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Abstract Classes]
    Are classes that stand in an ``\rd{is-a}'' relationship with their subclasses:
    \begin{figure}[H]	
      \centering
        \resizebox{0.35\linewidth}{!}{\tikzset{font=\Huge}\input{uml/abstract_class.tex}}
    \end{figure}
    \begin{itemizenosep}
      \item Cannot be instantiated
      \item Usually have one or more abstract methods
      \item May have attributes, constructors, non-abstract methods 
    \end{itemizenosep}
    \begin{mintlinebox}{java}
      visibility abstract class Name{ Body }
    \end{mintlinebox}
  \end{defn}
\end{defnbox}
\begin{notebox}[Note]\nospacing
  An abstract class must not necessarily have an abstract method.\\
  Useful to declare classes abstract that cannot/may not be initiated but are
  supposed to be extended.
\end{notebox}
\begin{notebox}[Note: \normalfont{Derived Classes}]\nospacing
  \begin{itemizenosep}
      \item Have to override (implement) all \javainline{abstract} methods
      \item Or have to be declared abstract as well, if not all abstract methods
    are overridden.
      \item Can only extend one Class.
  \end{itemizenosep}
\end{notebox}
\begin{notebox}[Note]\nospacing
  Arrays of an abstract base type may be instantiated sine no instances are
  created (only reference variables)
  \begin{mintlinebox}{java}
    ContainerType[] name = new ContainerType[Number]
  \end{mintlinebox}
\end{notebox}
\begin{stylebox}[Usage]\nospacing
  \begin{itemizenosep}
      \item Want to share code among several closely related classes.
      \item You expect that classes that extend your abstract class have many
    common methods or fields or require access modifiers other than public (such
    as protected and private).
      \item You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.
  \end{itemizenosep}
\end{stylebox}
\subsection{Interfaces}
\begin{defnbox}\nospacing
  \begin{defn}[Interfaces=pure abstract class]\label{defn:interfaces}
    Have to be implemented by the class that uses the interface and represent a
    ``\rd{can-do}'' relationship:
    \begin{figure}[H]	
      \centering
        \resizebox{0.35\linewidth}{!}{\tikzset{font=\Huge}\input{uml/interface.tex}}
    \end{figure}
    \begin{itemizenosep}
      \item Have only \javainline{public} and \javainline{abstract} methods
      \item Attributes are by default \javainline{public,static} and
    \javainline{final}
      \item No constructors $\Rightarrow$ instantiated ($\neq$ declared)
    \end{itemizenosep}
    \imp{Definition}:
    \begin{mintlinebox}{java}
      public intreface ClassName{ Body; }
    \end{mintlinebox}
    \imp{Implementation}:
    \begin{mintlinebox}{java}
      class ClassName implements IntefaceName{ Body; }
    \end{mintlinebox}
    \begin{itemizenosep}
        \item All methods defined in the declared interface have to be
      implemented unless its another interface adding more functionality
        \item A class may implement multiple interfaces
    \end{itemizenosep}
  \end{defn}
\end{defnbox}
\begin{notebox}[Note: Java 8 default methods]\nospacing
  Can be implemented inside interfaces and are able to access other methods.
  Allows to extend interfaces without breaking existing classes that implement
  the interface.
\end{notebox}
\begin{stylebox}\nospacing
  Use \javainline{@override} to implement the methods.
\end{stylebox}
\begin{stylebox}[Usage]\nospacing
  \begin{itemizenosep}
    \item You expect that unrelated classes would implement a piece of
  functionality. 
    \item Want to specify the behavior of a particular data type, but not concerned about who implements its behavior.
  \end{itemizenosep}
\end{stylebox}
\begin{notebox}[Interfaces as function arguments]\nospacing
  Methods with interfaces as function argument can be called with any class that
  implements the interface.
\end{notebox}
\begin{notebox}[Interface Reference]\nospacing
  Interfaces can be used as reference variable for all subclasses \imp{but} be
  care-full if the reference object implements another interface we will not be
  able to call its functions unless we use an implicit cast.\\
  Check if referenced object implements an interface: \javainline{ref instanceof aInterface}
\end{notebox}
\begin{codeboxNl}[Interaface Variable]{java}
  TypeImplementingAandB ref = new TypeImplementingAandB()
  InterfaceTypeA refA = ref;
  InterfaceTypeB refB = ref;
  refA instanceof InterfaceTypeB // True as ref implements B
  refA.methodOfTypeImplementingAandB() // works
  refA.methodOfB() // does not work
  ((InterfaceTypeB)refA).methodOfB() // works
\end{codeboxNl}
\begin{sectionbox}[Intrefaces and Abstract Classes]\nospacing
  \begin{itemize}
      \item \javainline{Interface}: provides a type
      \item \javainline{abstract Class} semi finished component that contains
    default implementations
    \begin{itemizenosep}
        \item which can be used in subclasses
        \item which can be overriden in subclasses
    \end{itemizenosep}
  \end{itemize}
  \begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{java/figures/oop/abstractInterface.png}
  \end{figure}
\end{sectionbox}
\begin{notebox}[Abstract Classes vs. Interfaces]\nospacing
  \begin{itemizenosep}
      \item Abstract Classes
    \begin{itemizenosep}
        \item A class may extend only one abstract class
        \item Abstract classes may contain attributes \& concrete implementations
    \end{itemizenosep}
      \item Interfaces
    \begin{itemizenosep}
        \item A class may implement several interfaces
        \item Interfaces may contain no implementations 
    \end{itemizenosep}
  \end{itemizenosep}
\end{notebox}
\begin{defnbox}\nospacing
  \begin{defn}[Anonymous Class]
    Is an inner class without a name and for which only a single object is
    created.
    An anonymous inner class can be useful when making an instance of an object
    with certain "extras"
    such as overloading methods of a class or interface, without having to
    actually subclass a class.\\
    The syntax of an anonymous class expression is like the invocation of a
    constructor,
    except that there is a class definition contained in a block of code.
\begin{mintlinebox}{java}
interface|\optc{/}|class MyClass{
  // definition
}

// Anonymous object with extras
MyClass obj = new MyClass() 
{
  // data members and methods
  @Override
  public my_func |\optc{typ}|(|\optc{typ}|) 
  {
    |\optldots|
  }   

  public new_func |\optc{typ}|(|\optc{typ}|) 
  {
    |\optldots|
  }   
};
\end{mintlinebox}
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[Marker Interface]\label{defn:markerInerface}
    Is an empty interface, that can be used to add a certain
    attribute/characteristic to a class that can be checked with
    \javainline{instanceof} e.g.\ RandomAcess 
  \end{defn}
\end{defnbox}
\begin{defnbox}\nospacing
  \begin{defn}[\\Functional Interface \javainline{@FunctionalInterface}]\label{defn:functionalInterface}
    Is an interface with a single abstract method:
    \begin{mintlinebox}{java}
      @FunctionalInterface
      public interface InterfaceName{
        visibility returnType methodName(args);
      }
    \end{mintlinebox}
  \end{defn}
\end{defnbox}
\begin{notebox}[Notes]\nospacing
  \begin{itemizenosep}
      \item The annotation \javainline{@FunctionalInterface} allows compilers to generate an
  error if the interface does not satisfy the conditions of a functional
  interface.
    \item Default methods are not abstract and do not count.
  \end{itemizenosep}
\end{notebox}
\begin{defnbox}\nospacing
  \begin{defn}[Lambda Expressions]
    Is a block of code that you can pass around so it can be executed later.
    \begin{mintlinebox}{java}
      |\optab{var = }|(|\optc{Typ1 arg1, Typ2 arg2,\ldots}|) -> |\optc{\text{single expressions}}|;
      // or
      |\optab{var = }|(|\optc{args}|) -> |\optc{\{\text{expressions}\}}|
    \end{mintlinebox}
    You never specify the result type of a lambda expression. It is always
    inferred from context.
  \end{defn}
\end{defnbox}
\begin{notebox}[Note]\nospacing
  \begin{itemizenosep}
      \item If the argument types the lambda expression can be inferred, we can
    omit them.
      \item For no arguments we still need to write empty parentheses
    \javainline{()}.
      \item If a method has a single parameter with inferred type, you can even
    omit the round parentheses:\\
    \begin{mintlinebox}{java}
    ActionListener listener = event ->
    System.out.println("The time is " + new Date());
    \end{mintlinebox}
  \end{itemizenosep}
\end{notebox}
\begin{defnbox}\nospacing
  \begin{defn}[\\Functional Interfaces Lambda Expressions]\label{defn:FunctionalInterfacesAndLambda}\leavevmode\\
    We can use Lambda expressions to define the anonymous functions at a point.\\
    This is really convenient as we do not have to define a subclass or
    anonymous class but can simply supply a lambda expression whenever an object
    of an interface with a single abstract method is expected.
    \begin{mintlinebox}{java}
    subj_obj.addActionListener((ActionEvent e) -> {
      |\optldots|
      });
      // or even just
    subj_obj.addActionListener(e -> {
      |\optldots|
      });
    \end{mintlinebox}
    \imp{Note}: the provided lambda function is than basically an
    \tc{section}{observer} (\cref{subsubsec:Observer}) getting triggered when the \tc{section}{subject}
    notifies this function.
  \end{defn}
\end{defnbox}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../formulary"
%%% End:
